# Socket
### 一、IO模型
一个输入操作通常包括两个阶段：
* 等待数据准备好
* 从内核向进程复制数据

对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所等待数据到达时，它被复制到内核中的某个缓冲区。第二部就是把数据从内存缓冲区复制到应用进程缓冲区

Unix有五种IO模型：
* 阻塞式IO
* 非阻塞式IO
* IO复用（select和poll）
* 信号驱动式IO（SIGIO）
* 异步IO（AIO）
  
#### 阻塞式IO
应用进程被阻塞，直到数据从内核缓冲区复制到应用进程缓冲区才返回
阻塞不以为着整个操作系统都阻塞，因为其他进程还可以执行，所以不消耗CPU时间，这种模型CPU效率比较高

#### 非阻塞式IO
应用进程执行系统调用后，内核返回一个错误码。应用进程可以继续执行，但是需要不断执行系统调用来获知IO是否完成，这种方式称为轮询（polling）
由于CPU要处理更多的系统调用，因此这种模型CPU效率较低

#### IO复用
使用select或者poll等待数据，并且可以等待多个套接字的任何一个变为可读，这一过程会被阻塞。当某一个套接字可读时返回，之后再使用 recvfrom 把数据从内核复制到进程中。
他可以让单个进程具有处理多个IO事件的能力，又被称为Event Drive IO，即事件驱动IO
如果一个 Web 服务器没有 I/O 复用，那么每一个 Socket 连接都需要创建一个线程去处理。如果同时有几万个连接，那么就需要创建相同数量的线程。相比于多进程和多线程技术，I/O 复用不需要进程线程创建和切换的开销，系统开销更小。

#### 信号驱动IO
应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以正常执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向应用进程发送 SIGIO 信号，应用进程收到后在信号处理程序中调用 recvfrom 将数据从内核复制到应用进程中
相对于非阻塞式IO的轮询方式，信号驱动IO的CPU利用率更高

#### 异步IO（AIO）
应用进程执行 aio_read 系统调用会立即返回，应用程序可以继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号
AIO和信号驱动IO的区别是，AIO的信号是通知应用进程IO完成，而信号驱动IO的信号是通知应用进程可以开始IO

#### 五种IO模型的比较
* 同步IO：将数据从内核缓冲区复制到应用进程缓冲区的阶段（第二阶段），应用进程会阻塞
* 异步IO：第二阶段应用进程不会阻塞
  
同步 I/O 包括阻塞式 I/O、非阻塞式 I/O、I/O 复用和信号驱动 I/O ，它们的主要区别在第一个阶段。
非阻塞式 I/O 、信号驱动 I/O 和异步 I/O 在第一阶段不会阻塞。
![avatar](../static/五种IO模型.png)

### 二、IO复用
select/poll/epoll都是IO多路复用的具体体现，select出现的最早，然后是poll，再是epoll

#### select
select 允许应用程序监视一组文件描述符，等待一个或多个文件描述符成为就绪状态，从而完成IO操作

#### poll
poll的作用和select类似，都是等待一组描述符中的一个成为就绪状态

#### 比较
1.功能
select 和 poll 的功能基本一致，不过在一些实现细节上有所不同
* select 会修改描述符，poll不会
* select 的描述符类型使用数组实现，FD_SETSIZE 大小默认为 1024，因此默认只能监听少于 1024 个描述符。如果要监听更多描述符的话，需要修改 FD_SETSIZE 之后重新编译；而 poll 没有描述符数量的限制；
* poll 提供了更多的事件类型，并且对描述符的重复利用上比 select 高。
* 如果一个线程对某个描述符调用了 select 或者 poll，另一个线程关闭了该描述符，会导致调用结果不确定

2.速度
select 和 poll 速度都比较慢，每次调用都需要将全部描述符从应用缓冲区复制到内核缓冲区

3.可移植性
几乎所有的系统都支持 select，但是只有比较新的系统支持 poll。

#### epoll
epoll_ctl() 用于向内核注册新的描述符或者是改变某个文件描述符的状态，已注册的描述符在内核中会被维护到一颗红黑树上，通过回调函数内核会将IO准备好的描述符加入到一个链表中进行管理，进程调用epoll_wait()便可以得到事件完成的描述符
epoll 只需要将描述符从进程缓冲区向内核缓冲区拷贝一次，并且进程不需要通过轮询来获得事件完成的描述符
epoll仅适用于Linux

epoll 比 select 和 poll 更加灵活而且没有描述符数量限制。
epoll 对多线程编程更有友好，一个线程调用了 epoll_wait() 另一个线程关闭了同一个描述符也不会产生像 select 和 poll 的不确定情况。

工作模式：LT 和 ET
LT：当 epoll_wait() 检测到描述符事件到达时，将此事件通知进程，进程可以不立即处理该事件，下次调用 epoll_wait() 会再次通知进程。是默认的一种模式，并且同时支持 Blocking 和 No-Blocking。
ET：和 LT 模式不同的是，通知之后进程必须立即处理事件，下次再调用 epoll_wait() 时不会再得到事件到达的通知。很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。只支持 No-Blocking，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。

#### 应用场景
##### select
select的timeout参数精度为微秒，而poll和epoll为毫秒，因此 select 更加适用于实时性要求比较高的场景，比如核反应堆的控制
select 可移植性更好，几乎被所有主流平台所支持

##### poll
poll 没有最大描述符数量的限制，如果平台支持并且对实时性要求不高，应该使用 poll 而不是 select

##### epoll
只需要运行在 Linux 平台上，有大量的描述符需要同时轮询，并且这些连接最好是长连接。
需要同时监控小于 1000 个描述符，就没有必要使用 epoll，因为这个应用场景下并不能体现 epoll 的优势。
需要监控的描述符状态变化多，而且都是非常短暂的，也没有必要使用 epoll。因为 epoll 中的所有描述符都存储在内核中，造成每次需要对描述符的状态改变都需要通过 epoll_ctl() 进行系统调用，频繁系统调用降低效率。并且 epoll 的描述符存储在内核，不容易调试