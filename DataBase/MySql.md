### MySql
MySql 是关系型数据库，默认端口号是 3306

### 存储引擎
默认存储引擎是 InnoDB，并且只有 InnoDB 可以支持事务

#### MyISAM 和 InnoDB 的区别
MyISAM 是 MySql 在5.5版本以前的默认存储引擎，虽然性能极佳，而且提供了大量的特性，包括全文索引，压缩和空间函数等，但 MyISAM 不支持事务和行级锁，而且最大的缺陷就是崩溃后无法安全恢复。5.5版本之后默认存储引擎更改为 InnoDB

MyISAM 在读密集的情况下可以使用

两者的对比：
1. 是否支持行级锁： MyISAM 只支持表级锁，而 InnoDB 支持行级锁和表级锁，默认为表级锁
2. 是否支持事务和崩溃后安全恢复：MyISAM 强调的是性能，每次查询具有原子性，其执行速度比 InnoDB 更快，但是不提供事务支持，但是 InnoDB 提供事务支持，外部键等高级数据库表功能。具有事务，回滚和崩溃修复能力的事务安全型表
3. 是否支持外键：MyISAM 不支持，而 InnoDB 支持
4. 是否支持 MVCC：仅 InnoDB 支持，应对高并发事务，MVCC 比单纯的加锁更高效；MVCC 只在 READ COMMITTED 和 REPEATABLE READ 两个隔离级别下功能；MVCC 可以使用乐观锁和悲观锁来实现；各数据库中 MVCC 实现并不统一
   
很多已知场景中，InnoDB 的速度都可以让 MyISAM 望尘莫及，尤其是用到了聚集索引，或者需要访问的数据都可以放入内存的应用

### 字符集及校对规则
字符集指的是一种从二进制编码到某类字符符号的映射，校对规则是指某种字符集下的排序规则。MySql 每一种字符集都会对应一系列的校对规则

### 链接池
MySql 中的连接池是维护与系统之间的多个数据库连接，除此之外，每次跟 MySql 建立连接时，还会根据传输过来的账号和密码，进行账号密码的验证，库表权限的验证

### 结构
SQL 解析器解析 SQL 语句 -> 查询优化器选择最优查询路径 -> 执行器根据执行计划不停地调用存储引擎接口去完成 SQL 的执行计划 -> 调用存储引擎接口，执行 SQL 语句，存储引擎会按照一定的步骤去查询内存缓存数据、更新磁盘数据、查询磁盘数据等

### 存储引擎 InnoDB
InnoDB 有一个非常重要的放在内存中的组件：缓冲池

执行阶段：查询时会先查询缓冲池，如果不在会查询磁盘并放入缓冲池，并对这行记录加独占锁，然后将更新前的值写入 undo 日志（便于回滚），之后再更新缓冲池中的数据，在缓冲池中记录 Redo 日志（MySql 宕机时用来恢复数据），之后提交事务时将 redo log buffer 刷入磁盘中

提交事务阶段：redo 日志刷盘策略分为 3 种，为 0 时，提交事务不会把 redo log  buffer 里的数据刷入磁盘中，为 1 时，提交事务时会把 redo log 刷入磁盘中，为 2 时，提交事务时会把 redo log 写入磁盘文件对应的 os cache 中，可能 1 秒后才会把 os cache 中的数据写入到磁盘文件中

bin log 归档日志不是 InnoDB 特有的，而是属于 Mysql Server 自己的，提交事务的时候会把 bin log 日志写入磁盘中，bin log 刷盘策略分为 2 中，为 0 时，写入 os cache 内存缓存；为 1 时，提交事务时直接刷入磁盘文件

当把 bin log 写入磁盘文件之后，会把本次更新对应的 bin log 文件名称和这次更新的 bin log 在文件里的位置都写入到 redo log 中，同时在 redo log 中写入一个 commit 标记，完成之后才最终完成事务的提交，commit 标记用来保证 redo log 和 bin log 完全一致

MySql 后台 IO 线程随机将内存更新后的脏数据刷回磁盘数据文件中

### 服务器配置
4核8G的 Java 应用系统，每秒并发量基本在几百左右。

数据库服务器通常是8核16G或者16核32G，16核32G的机器部署的 Mysql 数据库每秒并发请求可以在三四千

### Buffer Pool
数据页，MySql 对数据抽象出一个数据页的概念，他把很多行数据放到一个页中，更新一行数据时，数据库会先找到这行数据所在的数据页，然后从磁盘文件中把这行数据所在的数据页直接加载到 buffer pool 中

默认情况下，buffer pool 中的缓存页和磁盘中的数据页大小是一一对应的，都是16 KB

每个缓存页都有一个描述信息，包含缓存页所属的表空间、数据页编号、缓存页在缓存池中的地址等信息，描述信息本身也是一块数据，放在 buffer pool 中，描述信息大概相当于缓存页大小的 5% 左右，buffer poll 的 size 仅包含缓存页的大小，不包含描述信息的大小

数据库启动后，会按照设置的 buffer pool 的大小，稍微再加大一点，去申请内存，申请完毕后，数据库会按照默认的缓存页的 16 KB的大小以及对应的 800 个字节左右的描述数据的大小，在 Buffer Pool 中划分出来一个一个的缓存页和一个一个的他们对应的描述信息

为了得知 Buffer Pool 中哪些缓存页是空闲状态，数据库会为 Buffer Pool 设计一个 free 链表，他是一个双向链表，这个 free 链表每个节点是一个空闲的缓存页的描述数据块信息，只要缓存页是空闲的，那么他的描述数据块就会被放到这个 free 链表中

除此之外，free 链表还有一个头结点和一个尾结点，里面存储了链表中还有多少描述数据块的节点，即还有多少个空闲的缓存页

将磁盘的数据页读取到缓冲池时，先从 free 链表中获取一个描述数据块，然后就可以对应的获取到对应的空闲缓存页，接着就可以把磁盘上的数据页读取到对应的缓存页中，同时把一些描述信息写入到缓存页的描述数据块中，最后把这个描述数据块从 free 链表中除去即可

数据库还会有一个 hash 表数据结构，他会用表空间号+数据页号作为 key，缓存页地址作为 value，用于判断是否需要从磁盘中加载数据页

数据库还会引入一个 flush 链表，本质也是通过缓存页的描述数据块中的两个指针，让被修改的缓存页的描述数据块组成一个双向链表，用于判断缓存页是否为脏页

Buffer Pool 中还有一个 LRU 链表，最近最少使用，我们从磁盘中加载一个数据页到缓存页时，就把这个缓存页的描述数据块放到 LRU 链表头部，最近访问的缓存页信息都会被移动到头部

MySql 有预读机制，他从磁盘中加载数据页时，可能会连同这个数据页相邻的其他数据页都加载到缓存中。预读机制是为了避免大量的磁盘IO

预读机制的触发时机：
* innodb_read_ahead_threshold，默认值是56，如果顺序的访问了一个区里的多个数据页，访问的数据页的数量超过了这个阈值，此时就会触发预读机制，把下一个相邻区的所有数据页都加入缓存中
* innodb_random_read_ahead 来控制开关，如果 Buffer Pool 里缓存了一个区里的13个连续的数据页，而且这些数据页是频繁被访问的，那么就会触发预读机制，把这个区里的其他数据页都加载到缓存中去

LRU 链表会按37开的比例拆分为冷热两个部分，数据页第一次被加载到缓存时，缓存页会被放在冷数据区域的链表头部位置，1s之后如果缓存页被访问，则会被放到热数据区域的链表头部位置

Mysql 定时任务每隔一段时间清空 LRU 冷数据区域的缓存页以及 flush 链表中的缓存页，将它们刷回磁盘，把他们加入回 free 链表，移出 flush 链表和 LRU 链表

多线程操作同一个 Buffer Pool 的时候需要加锁，因此可以分配多个 Buffer Poll 来提升性能

Mysql 中有 chunk 机制，每个 buffer pool 由一系列 128M 的 chunk 组成，这些 chunk 共享一个 buffer pool 的 free、flush、lru 这些链表，通过 chunk 机制可以在运行时动态调整 buffer pool 的大小

### 磁盘
变长字段长度（16进制逆序排列）+null 值列（每个bit表示是否为null）+数据头（40bit）+实际数据值

数据头记录本行记录的一些类型以及下一行数据的指针

然后根据字符集编码，转换成一些数字和符号存储在磁盘上，同时会在实际数据值的部分中增加DB_ROW_ID（行唯一标识），DB_TRX_ID(事务ID)，DB_ROLL_PTR(回滚指针)

而一个数据页被拆成了很多部分，包含了文件头、数据页头、最小记录和最大记录、多个数据行、空闲空间、数据页目录、文件尾部

一个表空间对应着一些磁盘上的数据文件，这些磁盘上的数据文件中有很多的数据页

一个数据区对应着连续64个数据页，每个数据页是16KB，一个数据区是1M，256个数据区被划分为一组，每个表空间的第一个组数据区的第一个数据区的前三个数据页都是固定的，存放一些描述性数据。当我们需要执行 curd 操作的时候，说白了就是从磁盘上的表空间的数据文件里，随机访问去加载一些数据页到 Buffer Pool 的缓存页使用

redo log写入是磁盘顺序写，几乎和内存随机读写的性能差不多，redo log 写的越快，sql 语句的性能就越高

### 行溢出
当一行的数据大于数据页大小16KB时，会发生行溢出，溢出的数据会放到其他的数据页当中

### RAID 存储架构
RAID 就是一个磁盘冗余阵列，大致理解为用来管理机器的多块磁盘的一种磁盘阵列技术

RAID 还可以实现数据冗余机制，写入同样一份数据，会在两块磁盘上都写入

但是 RAID 锂电池自动充放电会导致数据库服务器 RAID 存储性能出现几十倍的抖动

### Redo Log
redo log 的日志格式大致为：对表空间XXX的数据页XXX中的偏移量为XXX的地方更新了数据XXX

表空间+数据页号+偏移量+修改几个字段的值+具体的值

redo log 不是单行写入日志文件的，而是通过 redo log block 来存放多个单行日志，redo log block 分为三部分：header（12字节）、body（496字节）、trailer（4字节）

header 可以继续细分：block no（4字节的块唯一编号）、data length（2个字节的已写入数据长度）、first record group（2字节的日志分组偏移量）、checkpoint on（4字节）

每一个redo log 都是写入到redo log磁盘文件里的一个 redo log block里去了，每个redo log block最多放496KB的redo log日志

redo log buffer 是Mysql 启动时向操作系统申请的一段连续的内存空间，里面划分了 n 个redo log block，默认为 16MB 大小，如果所有的 redo log block 全部写满，则会强制把 redo log block 刷入磁盘

一个事务中的所有redo log会等待sql全部执行完成后才会一起写入 redo log block

redo log block 输入磁盘的时机：

1. 如果写入redo log buffer 的日志已经占据了redo log buffer 空间的一半，此时会把他们刷入磁盘空间中

2. 一个事务提交的时候，必须把他的redo log 所在的 redo log block 都刷入到磁盘文件当中，需要设置参数

3. 后台线程定时刷新，有一个线程每隔1s就会把redo log buffer 中的redo log block刷到磁盘文件当中

4. Mysql 关闭的时候，redo log block都会刷入磁盘当中

磁盘中默认会有两个 redo log 文件，写入满后会覆盖另一个文件

### Undo log
