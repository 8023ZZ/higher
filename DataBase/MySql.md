### MySql
MySql 是关系型数据库，默认端口号是 3306

### 存储引擎
默认存储引擎是 InnoDB，并且只有 InnoDB 可以支持事务

#### MyISAM 和 InnoDB 的区别
MyISAM 是 MySql 在5.5版本以前的默认存储引擎，虽然性能极佳，而且提供了大量的特性，包括全文索引，压缩和空间函数等，但 MyISAM 不支持事务和行级锁，而且最大的缺陷就是崩溃后无法安全恢复。5.5版本之后默认存储引擎更改为 InnoDB

MyISAM 在读密集的情况下可以使用

两者的对比：
1. 是否支持行级锁： MyISAM 只支持表级锁，而 InnoDB 支持行级锁和表级锁，默认为表级锁
2. 是否支持事务和崩溃后安全恢复：MyISAM 强调的是性能，每次查询具有原子性，其执行速度比 InnoDB 更快，但是不提供事务支持，但是 InnoDB 提供事务支持，外部键等高级数据库表功能。具有事务，回滚和崩溃修复能力的事务安全型表
3. 是否支持外键：MyISAM 不支持，而 InnoDB 支持
4. 是否支持 MVCC：仅 InnoDB 支持，应对高并发事务，MVCC 比单纯的加锁更高效；MVCC 只在 READ COMMITTED 和 REPEATABLE READ 两个隔离级别下功能；MVCC 可以使用乐观锁和悲观锁来实现；各数据库中 MVCC 实现并不统一
   
很多已知场景中，InnoDB 的速度都可以让 MyISAM 望尘莫及，尤其是用到了聚集索引，或者需要访问的数据都可以放入内存的应用

### 字符集及校对规则
字符集指的是一种从二进制编码到某类字符符号的映射，校对规则是指某种字符集下的排序规则。MySql 每一种字符集都会对应一系列的校对规则

### 链接池
MySql 中的连接池是维护与系统之间的多个数据库连接，除此之外，每次跟 MySql 建立连接时，还会根据传输过来的账号和密码，进行账号密码的验证，库表权限的验证

### 结构
SQL 解析器解析 SQL 语句 -> 查询优化器选择最优查询路径 -> 执行器根据执行计划不停地调用存储引擎接口去完成 SQL 的执行计划 -> 调用存储引擎接口，执行 SQL 语句，存储引擎会按照一定的步骤去查询内存缓存数据、更新磁盘数据、查询磁盘数据等

### 存储引擎 InnoDB
InnoDB 有一个非常重要的放在内存中的组件：缓冲池

执行阶段：查询时会先查询缓冲池，如果不在会查询磁盘并放入缓冲池，并对这行记录加独占锁，然后将更新前的值写入 undo 日志（便于回滚），之后再更新缓冲池中的数据，在缓冲池中记录 Redo 日志（MySql 宕机时用来恢复数据），之后提交事务时将 redo log buffer 刷入磁盘中

提交事务阶段：redo 日志刷盘策略分为 3 种，为 0 时，提交事务不会把 redo log  buffer 里的数据刷入磁盘中，为 1 时，提交事务时会把 redo log 刷入磁盘中，为 2 时，提交事务时会把 redo log 写入磁盘文件对应的 os cache 中，可能 1 秒后才会把 os cache 中的数据写入到磁盘文件中

bin log 归档日志不是 InnoDB 特有的，而是属于 Mysql Server 自己的，提交事务的时候会把 bin log 日志写入磁盘中，bin log 刷盘策略分为 2 中，为 0 时，写入 os cache 内存缓存；为 1 时，提交事务时直接刷入磁盘文件

当把 bin log 写入磁盘文件之后，会把本次更新对应的 bin log 文件名称和这次更新的 bin log 在文件里的位置都写入到 redo log 中，同时在 redo log 中写入一个 commit 标记，完成之后才最终完成事务的提交，commit 标记用来保证 redo log 和 bin log 完全一致

MySql 后台 IO 线程随机将内存更新后的脏数据刷回磁盘数据文件中

### 服务器配置
4核8G的 Java 应用系统，每秒并发量基本在几百左右。

数据库服务器通常是8核16G或者16核32G，16核32G的机器部署的 Mysql 数据库每秒并发请求可以在三四千

### Buffer Pool
数据页，MySql 对数据抽象出一个数据页的概念，他把很多行数据放到一个页中，更新一行数据时，数据库会先找到这行数据所在的数据页，然后从磁盘文件中把这行数据所在的数据页直接加载到 buffer pool 中

默认情况下，buffer pool 中的缓存页和磁盘中的数据页大小是一一对应的，都是16 KB

每个缓存页都有一个描述信息，包含缓存页所属的表空间、数据页编号、缓存页在缓存池中的地址等信息，描述信息本身也是一块数据，放在 buffer pool 中，描述信息大概相当于缓存页大小的 5% 左右，buffer poll 的 size 仅包含缓存页的大小，不包含描述信息的大小

数据库启动后，会按照设置的 buffer pool 的大小，稍微再加大一点，去申请内存，申请完毕后，数据库会按照默认的缓存页的 16 KB的大小以及对应的 800 个字节左右的描述数据的大小，在 Buffer Pool 中划分出来一个一个的缓存页和一个一个的他们对应的描述信息

为了得知 Buffer Pool 中哪些缓存页是空闲状态，数据库会为 Buffer Pool 设计一个 free 链表，他是一个双向链表，这个 free 链表每个节点是一个空闲的缓存页的描述数据块信息，只要缓存页是空闲的，那么他的描述数据块就会被放到这个 free 链表中

除此之外，free 链表还有一个头结点和一个尾结点，里面存储了链表中还有多少描述数据块的节点，即还有多少个空闲的缓存页

将磁盘的数据页读取到缓冲池时，先从 free 链表中获取一个描述数据块，然后就可以对应的获取到对应的空闲缓存页，接着就可以把磁盘上的数据页读取到对应的缓存页中，同时把一些描述信息写入到缓存页的描述数据块中，最后把这个描述数据块从 free 链表中除去即可

数据库还会有一个 hash 表数据结构，他会用表空间号+数据页号作为 key，缓存页地址作为 value，用于判断是否需要从磁盘中加载数据页

数据库还会引入一个 flush 链表，本质也是通过缓存页的描述数据块中的两个指针，让被修改的缓存页的描述数据块组成一个双向链表，用于判断缓存页是否为脏页

Buffer Pool 中还有一个 LRU 链表，最近最少使用，我们从磁盘中加载一个数据页到缓存页时，就把这个缓存页的描述数据块放到 LRU 链表头部，最近访问的缓存页信息都会被移动到头部

MySql 有预读机制，他从磁盘中加载数据页时，可能会连同这个数据页相邻的其他数据页都加载到缓存中。预读机制是为了避免大量的磁盘IO

预读机制的触发时机：
* innodb_read_ahead_threshold，默认值是56，如果顺序的访问了一个区里的多个数据页，访问的数据页的数量超过了这个阈值，此时就会触发预读机制，把下一个相邻区的所有数据页都加入缓存中
* innodb_random_read_ahead 来控制开关，如果 Buffer Pool 里缓存了一个区里的13个连续的数据页，而且这些数据页是频繁被访问的，那么就会触发预读机制，把这个区里的其他数据页都加载到缓存中去

LRU 链表会按37开的比例拆分为冷热两个部分，数据页第一次被加载到缓存时，缓存页会被放在冷数据区域的链表头部位置，1s之后如果缓存页被访问，则会被放到热数据区域的链表头部位置

LRU 尾部的缓存页会有定时任务每隔一段时间清空这几个缓存页，将它们刷回磁盘，把他们加入回 free 链表，移出 flush 链表和 LRU 链表
