### 时间轮
Kafka时间轮的底层就是一个环形数组，而数组中每个元素都存放一个双向链表TimerTaskList，链表中封装了很多延时任务。

Kafka中一个时间轮TimingWheel是由20个时间格组成，wheelSize = 20；每格的时间跨度是1ms，tickMs = 1ms。

整个时间轮的时间跨度就是 tickMs * wheelSize 

每一个定时任务都有延时时间delayTime，和过期时间ExpiredTime。比如当前时间是10s，我们添加了个延时时间为2s的任务，那么这个任务的过期时间就是12s，也就是当前时间10s再走两秒，变成了12s的时候，就到了触发这个定时任务的时间。

对于大量请求，每个请求对应一个定时任务，需要大量的插入/删除操作，因此采用了多层时间轮来降低插入/删除的时间复杂度，出于避免重复造轮子的考虑，Kafka 仍然借助 Java 标准库的延时队列来推进时间轮

1. 是任务的添加与移除，都是O(1)级的复杂度；

2. 不会占用大量的资源；

3. 只需要有一个线程去推进时间轮就可以工作了

### IO 效率高
入数据的时候第一个就是因为kafka是顺序写入数据的，把普通的那种随机IO变成了顺序IO，这样的话写入数据的速度就比较快

kafka读取数据的时候是基于sendfile实现Zero Copy：
* sendfile系统调用，文件数据被copy至内核缓冲区
* 再从内核缓冲区copy至内核中socket相关的缓冲区
* 最后再socket相关的缓冲区copy到协议引擎

kafka的数据压缩，Kafka使用了批量压缩，即将多个消息一起压缩而不是单个消息压缩

kafka的生产者在进行生产消息的时候，采用的是批量发送和双线程，其实就是使用了双线程，主线程和Sender线程。主线程负责将消息置入客户端缓存，Sender线程负责从缓存中发送消息，而这个缓存会聚合多个消息为一个批次。有些消息中间件会把消息直接扔到broker