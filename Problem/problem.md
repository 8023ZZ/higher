### JVM 优化
思路为尽量让每次 YGC 后的存活对象数量小于 S 区的 50%，都留存在年轻代，尽量避免 FGC

上线前预估用户量，日活量，核心业务，高峰 QPS，对象生成量，内存占用量，YGC 触发频率，对象存活量，FGC 触发频率，空间分配

开发完毕后进行压测，借助 jstat 查看 JVM 运行状态，优化好参数

上线后使用 jstat、jmap、jhat 等在高峰期和低峰期进行检测，查看是否需要优化。或者使用 Zabbix、OpenFalcon、Ganglia 等开源工具进行监控

### SQL 调优
用户千万级，日活用户百万级

有两张表，一张存储用户的核心信息，另一张存储用户的拓展信息，有一条sql，子查询针对拓展信息表查询最近一次登录记录在某个时间点之前的用户，然后在外层查询用户信息并向用户推送。

业务运行时会先 count ，基于count 结果进行分页，但是目前 count 需要几十秒钟才能跑出来

生成执行计划，发现子查询是先通过range查出数据，然后 MATERIALIZED 对子查询查处的数据进行物化，落地到磁盘文件中，这个过程会很慢。第二条执行计划是外查询的全表扫描，并且是 Using Join Buffer 进行连接。查询计划的第一条是对子查询生成的物化临时表进行全表扫描，原因是让外查询的数据和子查询的物化表进行连接，找出匹配关系，生成结果集

但是 id 上明明有索引但是却没走，而是全表扫描，是因为 semi join 会走硬盘化，没有主键 ID

于是通过 show warnings 命令发现 mysql 在生成执行计划时，自动把一个普通的 In 语句优化成了基于 semi join 来进行 in + 子查询的操作，而 semi join 就是在外表中去匹配内表的物化临时表的数据，如果匹配上，那边外表的数据就会返回，它是用来进行筛选的，外表此时作为驱动表

如果关闭 semi-join 半连接优化，就会恢复为正常状态，会基于 range 扫描子表，然后会有一个 PRIMARY 的主查询，基于 id 的主键聚簇索引去执行 const 搜索

因此需要改写 sql 语句，在 id 的 in 条件同级增加一个 or，使得 Mysql 不会对这条 sql 进行半连接优化，性能提升到了几百毫秒的级别

当子查询位于 where 或者 join on 子句中，且首层不存在 or/not 操作（即首层的条件子句只能是 AND 操作符连接的表达式）可以进行半连接优化，但是如果与 OR 在同层，那就只能用 “物化” 策略优化

子查询比较大，并且能用上索引的情况下，最好禁用 semi join

### SQL 优化
