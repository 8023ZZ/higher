### JVM 优化
思路为尽量让每次 YGC 后的存活对象数量小于 S 区的 50%，都留存在年轻代，尽量避免 FGC

上线前预估用户量，日活量，核心业务，高峰 QPS，对象生成量，内存占用量，YGC 触发频率，对象存活量，FGC 触发频率，空间分配

开发完毕后进行压测，借助 jstat 查看 JVM 运行状态，优化好参数

上线后使用 jstat、jmap、jhat 等在高峰期和低峰期进行检测，查看是否需要优化。或者使用 Zabbix、OpenFalcon、Ganglia 等开源工具进行监控

### SQL 查询调优
用户千万级，日活用户百万级

有两张表，一张存储用户的核心信息，另一张存储用户的拓展信息，有一条sql，子查询针对拓展信息表查询最近一次登录记录在某个时间点之前的用户，然后在外层查询用户信息并向用户推送。

业务运行时会先 count ，基于count 结果进行分页，但是目前 count 需要几十秒钟才能跑出来

生成执行计划，发现子查询是先通过range查出数据，然后 MATERIALIZED 对子查询查处的数据进行物化，落地到磁盘文件中，这个过程会很慢。第二条执行计划是外查询的全表扫描，并且是 Using Join Buffer 进行连接。查询计划的第一条是对子查询生成的物化临时表进行全表扫描，原因是让外查询的数据和子查询的物化表进行连接，找出匹配关系，生成结果集

但是 id 上明明有索引但是却没走，而是全表扫描，是因为 semi join 会走硬盘化，没有主键 ID

于是通过 show warnings 命令发现 mysql 在生成执行计划时，自动把一个普通的 In 语句优化成了基于 semi join 来进行 in + 子查询的操作，而 semi join 就是在外表中去匹配内表的物化临时表的数据，如果匹配上，那边外表的数据就会返回，它是用来进行筛选的，外表此时作为驱动表

如果关闭 semi-join 半连接优化，就会恢复为正常状态，会基于 range 扫描子表，然后会有一个 PRIMARY 的主查询，基于 id 的主键聚簇索引去执行 const 搜索

因此需要改写 sql 语句，在 id 的 in 条件同级增加一个 or，使得 Mysql 不会对这条 sql 进行半连接优化，性能提升到了几百毫秒的级别

当子查询位于 where 或者 join on 子句中，且首层不存在 or/not 操作（即首层的条件子句只能是 AND 操作符连接的表达式）可以进行半连接优化，但是如果与 OR 在同层，那就只能用 “物化” 策略优化

子查询比较大，并且能用上索引的情况下，最好禁用 semi join

### SQL 查询调优
商品系统大量慢查询导致数据库链接数打满，商品系统本身TPS在几千，监控发现每分钟慢查询超过10W，出问题的sql大概是 select * from products where catagory = 'xx' and sub_catagory = 'xx' order by id desc limit xx,xx

商品表大概是一亿的数据量，这个量级很稳定，但是该语句执行需要几十秒钟，正常来说这个sql 执行速度应该在一秒以内

查看执行计划发现 mysql 并未使用索引，而是直接使用了主键的聚簇索引，而且扫描时 Using Where 使用 where 条件里的两个字段进行筛选

通过使用 force_index(index) 语法来强制使用指定索引，性能瞬间提升到几百毫秒级别

原执行计划需要先从二级索引中查到符合 where 条件的数据，然后还需要回表到聚簇索引中把所有的数据都查出来，但是回表之前需要先做完 order by id desc limit xx, xx的操作，也就是需要先对二级索引中查出来的数据基于临时磁盘文件或者内存进行 filesort 排序，排序完之后再按照 limit xx,xx 语法，拿出指定位置的数据，之后再把拿出来的数据回聚簇索引中查出完整字段。Mysql 优化是担心二级索引中查出的数据过多导致排序过慢，因此优化为直接扫描主键的聚簇索引，主键聚簇索引是有序的，可以直接倒序顺序扫描过去，所以他倒序扫描时，对每条数据采用 Using Where，符合条件就放入结果集，因为 where 条件在扫描聚簇索引的时候，通常都能很快找到符合条件的值和返回值，所以之前性能并没有问题

但是运营人员加了几种新的分类，但是这些分类在商品表里并没有对应的商品，所以底层在扫描聚簇索引时相当于全表扫描，导致慢查询出现，进而数据库连接池打满

### SQL 查询优化
针对一个商品几十万评论的深分页的问题

select * from comments where product_id = 'xx' and is_good_comment = '1' order by id desc limit 100000,20

索引不包含 is_good_comment，所以每次都需要回表进行查询，所以需要向聚簇索引方向改造

因此改造成 select * from comments a, (select id from comments where product_id = 'xx' and is_good_comment = '1' order by id desc limit 100000,20) b where comments.id = b.id

这样会执行子查询，子查询会使用 PRIMARY 聚簇索引，按照聚簇索引的 id 值倒序扫描，筛选到符合 where 条件的结果集，生成临时表，然后对这个临时表进行全表扫描，然后对每个 id 去聚簇索引里查找完整数据

### SQL 优化
慢查询本身不一定是 sql 导致的，可能是由于磁盘、网络以及CPU 的原因导致的

删除大量数据的如果是一个长事务，会导致 undo log 版本链过长，因此会导致慢查询，只要杀掉这个长事务即可恢复

### 数据库系统设计
500 W注册用户，50 W日活，每日 1 W订单，每年新增 360 W行

拆分的时候一般考虑三个维度
* 按照 id 为粒度进行分库分表，也就是把 id 进行 hash 后，对表数量取模然后把订单均匀分散到 100~1000 个表中，再把这些表分散在多台服务器上
* 用户端建立索引映射表，userId 到 orderId 的映射，然后去分表分库
* 公司端数据同步到 ES 来进行复杂搜索

分库分表可能会带来分布式事务的问题，需要进行解决

分布式主键常用雪花算法

如果要在分库分表环境下搞分页，最好保证一个主属性粒度是分库分表的粒度

也可以用 tidb 分布式数据库，把分库分表向用户隐藏