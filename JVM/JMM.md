### 对 JAVA 内存模型的理解
内存模型是硬件级别的内存读写操作
主内存 + 工作内存，工作内存是每个线程独有，使用 CPU 的高速缓存，工作内存是一个抽象概念，涵盖缓存和寄存器
read -> load -> use， assign -> store -> write
lock: 作用于主内存的变量，一个变量在同一时间只能被一个线程锁定，该操作表示线程独占这个变量
unlock：从锁定状态释放
read：作用于主内存变量，表示把一个主内存变量值读取到线程的工作内存
load：作用于线程的工作内存的变量，表示把read从主内存读取到的变量的值放到工作内存的变量副本中
user：作用于工作内存的变量，表示把变量的值传递给执行引擎，
cpu 内存是机器上 cpu 部分的，jvm 的堆内存是机器上内存条部分

### JAVA 内存模型中的原子性、有序性、可见性是什么
1. 可见性
对于变量的修改是否可见,可见性有三种方式：volatile，synchronized，final
2. 原子性
原子操作，同时成功或者同时失败，执行过程中别的线程不可执行，只能通过 synchronized 或者 lock
3. 有序性
编译器和指令器为了提升代码执行效率/处理器运行效率，会将指令重新排序，单线程情况下处理器会保证代码重排序后执行代码的结果不变，却会影响到多线程并发执行的正确性。也可以通过 synchronized 来保证有序性，它保证每个时刻只有一个线程执行同步代码，相当于是让线程顺序执行同步代码。

### volatile 关键字的原理
volatile 关键字是用来解决可见性和有序性，很少情况下可以有限的保证原子性(64位long的数字进行操作可以保证原子性)。
变量被修改后，volatile 会让其他线程的工作内存的变量值失效，需要用到该变量时就会重新去主内存加载最新的变量值
volatile 可以在一定程度上保证有序性：
* 当程序执行到 volatile 变量的读操作或者写操作时，在其前面执行的操作的更改必须全部完成，且结果对后面的操作可见，在其后面的操作肯定还没有进行
* 在进行指令重排时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行

### volatile 底层如何基于内存屏障去保证可见性和有序性的的
1. lock 指令：volatile 保证可见性
对 volatile 修饰的变量执行写操作时，JVM 会发送一个lock前缀指令给CPU， CPU计算完后会立即将这个值写回主内存，同时因为有MESI缓存一致性协议，所以各个CPU都会对总线进行嗅探，自己本地缓存中的数据是否被别人修改
lock 前缀指令 + MESI 缓存一致性协议
2. 内存屏障：volatile 禁止指令重排序
LoadLoad屏障： Load1，LoadLoad，Load2，确保Load1数据的装载先于Load2后所有的装载指令，Load1和Load2对应的代码不能进行指令重排
StoreStore屏障：Store1，StoreStore，Store2，确保Store1的数据一定刷回主存，对其他CPU可见，先于Store2以及后续指令
LoadStore屏障：Load1，LoadStore，Store2，确保Load1指令的数据装载先于Store2以及后续指令
StoreLoad屏障：Store1，StoreLoad，Load2，确保Store1指令的数据一定刷回主存，对其他CPU可见，先于Load2以及后续指令的数据装载
每个volatile写操作前面，加StoreStore屏障，禁止上面的普通写和他重排；每个volatile写操作后面加StoreLoad屏障，禁止跟下面的volatile读/写重排
每个volatile读操作后面，加LoadLoad屏障，禁止下面的普通读和volatile读重排；每个volatile读操作后面，加LoadStore屏障，禁止下面的普通写和volatile重排

### 指令重排和 happens-before 原则是什么
happens-before：
* 程序次序规则：在一个线程内，写在前面的操作先发生于后面的操作
* 锁定规则：unLock 操作先发生于后面对同一个锁的 lock 操作
* volatile：对一个volatile变量的写操作先发生于后面这个volatile变量的读操作
* 传递规则：操作A先行于操作B，操作B先行与操作C，则操作A先行与操作C
* 线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作
* 线程中断规则：线程中所有的操作都先行发生于线程的终止检测
* 对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始

程序中的代码如果满足这个这些条件，就一定会按照这个规则来进行排序，这个规则制定了一些特殊情况下，不允许编译器、指令器对代码进行指令重排，必须保证代码的有序性，但是如果未满足或者在8条规则之外则可以随意重排指令
